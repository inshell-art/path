<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Path-Look Devnet Grid</title>
  <style>
    :root {
      --bg: #0b0c0f;
      --card: #151821;
      --accent: #59f8c3;
      --text: #e9ecf2;
      --muted: #8a90a3;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 20px;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      background: radial-gradient(circle at 20% 20%, #12203b, #0b0c0f 45%), radial-gradient(circle at 80% 0%, #1b2c46, transparent 40%);
      color: var(--text);
    }
    h1 { margin: 0 0 4px 0; font-size: 24px; }
    .subtitle { color: var(--muted); margin-bottom: 16px; }
    .controls { display: flex; align-items: center; gap: 12px; margin-bottom: 12px; flex-wrap: wrap; }
    .controls input {
      background: #0f1119;
      border: 1px solid #1f2533;
      color: var(--text);
      padding: 8px 10px;
      border-radius: 6px;
      min-width: 220px;
    }
    button {
      background: var(--accent);
      color: #062e22;
      border: none;
      padding: 8px 12px;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
    }
    button:hover { filter: brightness(1.05); }
    .status { color: var(--muted); font-size: 13px; }
    .grid {
      display: grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap: 12px;
    }
    .card {
      background: linear-gradient(160deg, #181c27, #0f1119);
      border: 1px solid #1f2533;
      border-radius: 10px;
      padding: 10px;
      min-height: 200px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.35);
    }
    .meta {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: var(--muted);
    }
    .preview {
      background: #0a0b0f;
      border: 1px solid #1e2230;
      border-radius: 6px;
      min-height: 160px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    .preview img {
      width: 100%;
      display: block;
    }
    .preview-stack {
      display: grid;
      gap: 8px;
    }
    .preview-title {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }
    @media (max-width: 1100px) {
      .grid { grid-template-columns: repeat(4, minmax(0, 1fr)); }
    }
    @media (max-width: 900px) {
      .grid { grid-template-columns: repeat(3, minmax(0, 1fr)); }
    }
    @media (max-width: 640px) {
      .grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }
  </style>
</head>
<body>
  <h1>Path-Look Devnet Grid</h1>
  <div class="subtitle">Rendering from PathLook via the IGlyph interface. Tokens must exist in PathNFT.</div>
  <div class="controls">
    <button id="reload">Reload</button>
    <input id="tokenIds" type="text" value="1-20" aria-label="Token IDs" />
    <div class="status" id="status">Idle</div>
  </div>
  <div class="status">RPC: http://127.0.0.1:5050 · PathLook: 0x01082c3250672f65942ceb2283bdd27ec495b2d61b13d601b65c781c36706f09 · PathNFT: 0x0388aafe5db65e6bbafb10def6bea631d338f2edde2a8f763b7821d12d7e95de</div>
  <div class="grid" id="grid"></div>

  <script src="./vendor/starknet/index.global.js"></script>
  <script>
    const { RpcProvider } = window.starknet;

    const RPC_URL = 'http://127.0.0.1:5050';
    const CONTRACT_ADDRESS = '0x01082c3250672f65942ceb2283bdd27ec495b2d61b13d601b65c781c36706f09';
    const PATH_NFT_ADDRESS = '0x0388aafe5db65e6bbafb10def6bea631d338f2edde2a8f763b7821d12d7e95de';

    const provider = new RpcProvider({ nodeUrl: RPC_URL });
    const gridEl = document.getElementById('grid');
    const statusEl = document.getElementById('status');
    const tokenInput = document.getElementById('tokenIds');

    function decodeByteArray(felts) {
      if (!felts || felts.length < 3) return "";

      let fullCount = Number(BigInt(felts[0]));
      let fullWords = felts.slice(1, 1 + fullCount);
      let lastWord = felts[1 + fullCount];
      let lastLen = Number(BigInt(felts[2 + fullCount] ?? 0));

      // Fallback for mismatched headers: treat everything but the last two as data.
      if (felts.length !== fullCount + 3) {
        fullCount = Math.max(0, felts.length - 3);
        fullWords = felts.slice(1, 1 + fullCount);
        lastWord = felts[felts.length - 2];
        lastLen = Number(BigInt(felts[felts.length - 1] ?? 0));
      }

      const bytes = [];
      for (let i = 0; i < fullWords.length; i++) {
        const hex = BigInt(fullWords[i]).toString(16).padStart(62, "0");
        for (let j = 0; j < 31; j++) {
          bytes.push(parseInt(hex.slice(j * 2, j * 2 + 2), 16));
        }
      }

      if (lastLen > 0 && lastWord !== undefined) {
        const hex = BigInt(lastWord).toString(16).padStart(62, "0");
        const start = hex.length - lastLen * 2;
        for (let i = start; i < hex.length; i += 2) {
          bytes.push(parseInt(hex.slice(i, i + 2), 16));
        }
      }

      const raw = new TextDecoder().decode(new Uint8Array(bytes));
      return raw;
    }

    function parseTokenIds(raw) {
      const tokens = raw.split(/[\s,]+/).filter(Boolean);
      const ids = [];
      for (const token of tokens) {
        if (token.includes('-')) {
          const [startRaw, endRaw] = token.split('-');
          const start = Number(startRaw);
          const end = Number(endRaw);
          if (!Number.isFinite(start) || !Number.isFinite(end)) continue;
          const step = start <= end ? 1 : -1;
          for (let i = start; i !== end + step; i += step) {
            if (i > 0) ids.push(i);
          }
        } else {
          const value = Number(token);
          if (Number.isFinite(value) && value > 0) {
            ids.push(value);
          }
        }
      }
      return Array.from(new Set(ids)).slice(0, 100);
    }

    function toU256(value) {
      const big = BigInt(value);
      const low = big & ((1n << 128n) - 1n);
      const high = big >> 128n;
      return [low.toString(), high.toString()];
    }

    async function fetchDataUri(tokenId, entrypoint) {
      const call = {
        contractAddress: CONTRACT_ADDRESS,
        entrypoint,
        calldata: [PATH_NFT_ADDRESS, ...toU256(tokenId)],
      };
      const result = await provider.callContract(call, 'latest');
      return decodeByteArray(result.result);
    }

    async function fetchMetadata(tokenId, entrypoint) {
      const call = {
        contractAddress: CONTRACT_ADDRESS,
        entrypoint,
        calldata: [PATH_NFT_ADDRESS, ...toU256(tokenId)],
      };
      const result = await provider.callContract(call, 'latest');
      const raw = decodeByteArray(result.result);
      try {
        return { json: JSON.parse(raw), raw };
      } catch (err) {
        console.error('metadata parse failed', { tokenId, entrypoint, err, rawLen: raw.length, raw: raw.slice(0, 200) });
        return { json: null, raw };
      }
    }

    function dataUriToSvg(uri) {
      if (!uri || !uri.startsWith('data:image/svg+xml')) return '';
      const comma = uri.indexOf(',');
      if (comma === -1) return '';
      const encoded = uri.slice(comma + 1);
      // Tolerate stray '%' by escaping invalid sequences before decode.
      const sanitized = encoded.replace(/%(?![0-9a-fA-F]{2})/g, '%25');
      return decodeURIComponent(sanitized);
    }

    function entryLabel(tokenId) {
      return `#${tokenId}`;
    }

    async function renderGrid() {
      statusEl.textContent = 'Loading...';
      gridEl.innerHTML = '';

      const tokenIds = parseTokenIds(tokenInput.value);
      const entries = tokenIds.map((tokenId) => ({ tokenId }));

      for (const entry of entries) {
        const card = document.createElement('div');
        card.className = 'card';
        card.innerHTML = `
          <div class="meta">${entryLabel(entry.tokenId)}</div>
          <div class="preview-stack">
            <div>
              <div class="preview-title">path</div>
              <div class="preview" data-preview="svg"><span style="color: var(--muted); font-size: 12px;">Loading…</span></div>
            </div>
          </div>
        `;
        gridEl.appendChild(card);

        try {
          const svgUri = await fetchDataUri(entry.tokenId, 'generate_svg_data_uri');

          const preview = card.querySelector('[data-preview="svg"]');
          preview.innerHTML = `<img src="${svgUri}" alt="path look ${entry.tokenId}" />`;

          const meta = await fetchMetadata(entry.tokenId, 'get_token_metadata');
          const traits = meta.json?.attributes ?? [];
          const traitsHtml = traits.length > 0
            ? traits.map(t => `<div class="trait"><span>${t.trait_type}</span><span>${t.value}</span></div>`).join('')
            : `<div class="trait"><span>metadata</span><span>unavailable</span></div>`;
          const traitsBox = document.createElement('div');
          traitsBox.className = 'traits';
          traitsBox.innerHTML = traitsHtml;
          card.appendChild(traitsBox);
        } catch (err) {
          const preview = card.querySelector('[data-preview="svg"]');
          const msg = err && err.message ? err.message : String(err);
          preview.textContent = 'Error loading';
          preview.title = msg;
          console.error('fetchDataUri failed', entry, err);
        }
      }

      statusEl.textContent = 'Done';
    }

    document.getElementById('reload').addEventListener('click', renderGrid);
    renderGrid();
  </script>
  <style>
    .traits {
      margin-top: 6px;
      padding: 6px 8px;
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid #1f2533;
      border-radius: 6px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 4px 8px;
      font-size: 11px;
      color: var(--muted);
    }
    .trait {
      display: flex;
      justify-content: space-between;
    }
    .trait span:last-child {
      color: var(--text);
    }
  </style>
</body>
</html>
